<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mysql on Tars</title>
    <link>https://gargantuaX.github.io/categories/mysql/</link>
    <description>Recent content in Mysql on Tars</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zn-Hans</language>
    <lastBuildDate>Wed, 07 Nov 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://gargantuaX.github.io/categories/mysql/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Mysql中in vs join</title>
      <link>https://gargantuaX.github.io/blog/2018-11/mysql%E4%B8%ADin-vs-join/</link>
      <pubDate>Wed, 07 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://gargantuaX.github.io/blog/2018-11/mysql%E4%B8%ADin-vs-join/</guid>
      <description>简述 最近在一个群里看到join和in的争论，到底什么时候用in，什么时候用join，我做了实验来验证 预备知识 join type介绍 join type并非指join类型，而是查询类型 explain sql后的type字段正是join type Mysql中有以下join type，性能从高到底为： * system : 系统常量表 * const : 常量表 * eq_ref : 主键或者唯一索引 * ref : 非空索引 * ref_or_null : 可空索引 * range :索引列使用 BETWEEN, IN, &amp;gt;=, LIKE等范围查询 * index : 循序扫描索引列 * ALL : 顺</description>
    </item>
    
    <item>
      <title>读《高性能mysql》笔记</title>
      <link>https://gargantuaX.github.io/blog/2017-03/%E8%AF%BB%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 09 Mar 2017 02:39:26 +0000</pubDate>
      
      <guid>https://gargantuaX.github.io/blog/2017-03/%E8%AF%BB%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%94%E8%AE%B0/</guid>
      <description>性能监控工具 sysbench pt-query-digest Anemometer new rilic xhprof生产环境下的PHP性能跟踪工具 show profile show status 选择正确的数据类型 通常越小越好 越简单越好 采用not null 使用枚举类型 TIMESTAMP通常优于DATETIME 多表关联，关联主键数据类型应当一致 不要怕用NULL,避免不存在的值，如：DATETIME NOT NULL DEFAULT &amp;lsquo;0000-00-00 00:00:00&amp;rsquo; 在冗余量允许的情况下，减少JOIN，考虑适当把同一个字段数据存到不同表里，使用触发器来维护，这可以减少全表扫描。 建立合适的索</description>
    </item>
    
  </channel>
</rss>